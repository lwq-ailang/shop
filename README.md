##项目结构：
    shop-parent：父工程
    shop-common：工具工程
    shop-api：接口层
    shop-pojo：实体类
    shop-order-web：订单系统
    shop-pay-web：支付系统
    shop-coupon-service：优惠券服务
    shop-goods-service：商品服务
    shop-user-service：用户服务
    shop-order-service：订单服务
    shop-pay-service：支付服务
    

####1.校验订单
    1)校验订单是否存在：判断订单参数是否为空
    2)校验订单中的商品是否存在：根据订单传来的商品id查询商品是否存在
    3)校验下单用户是否存在：根据订单传来的用户id查询用户是否存在
    4)校验商品单价是否合法：商品单价 ？ 订单单价
    5)校验订单商品数量是否合法：商品数量 ？ 订单数量

####2.生成预订单
    1)设置订单状态为不可见
    2)设置订单ID：使用雪花算法，防止分库分表订单id重复
    3)核算订单运费：订单传进来的运费 ？ 计算订单所需要的运费（可以根据数量，价格等自定义规则）
    4)核算订单总金额是否合法：订单总金额 ？ 订单总价 + 运费价格
    5)判断用户是否使用余额：余额是否足够
    6)判断用户是否使用优惠券：优惠券是否合法
    7)核算订单支付金额：订单总金额 - 余额 - 优惠券金额
    8)设置下单时间
    9)保存订单到数据库
    10)返回订单ID

####3.扣减库存
    1)对比库存数量是否足够
    2)若扣减成功，则更新商品的库存数量和记录到订单商品日志表(订单id，商品id，商品数量等)

####4.扣减优惠券
    1)校验订单中是否包含优惠券id
    2)更新优惠券状态

####5.使用余额
    1)校验订单中余额是否合法
    2)设置用户余额日志表对象[注意：日志类型 1订单付款 2 订单退款]
    3)根据用户id和订单id去余额使用日志查询订单，判断日志中是否有该用户的订单记录
    4)付款-扣减余额（若订单记录>0，已经付款；否则更新用户余额）
    5)退款-回退余额（若订单记录<0,订单未付款；否则更新用户余额）,防止多次退款，需要再次查询余额使用日志表的订单状态
    6)记录到用户余额日志表

####6.确认订单
    1)更新最终订单成功，返回成功状态

####8.确认订单失败,返回失败状态
    1)往MQ发送消息:
        *goodService --【回退库存幂等性处理如下：】
            1. 解析消息内容
            2. 查询消息消费记录
            3. 如果消费过
                3.1 获得消息处理状态：
                    3.1.1 处理过...返回；
                    3.1.2 正在处理...返回；
                    3.1.3 处理失败大于3次...返回。
                          小于3次，数据库乐观锁方式更改消息状态为正在处理，更新到数据库，执行4.1和4.2
                                防止在高并发的时候，多个线程同时处理，保证数据的互斥性
            4. 如果没有消费过,更改消息状态为正在处理，将消息处理信息添加到数据库
                4.1 回退库存：商品数量 + 回退数量
                4.2 更新消息的处理状态改为成功

####注意：保证原子性：3,4,5,6,7保持一致性，一起成功，一起失败

####第三方回调
    *payService
        1. 判断用户支付状态：未支付往下走
        2. 先获取订单，判断订单是否存在，更新支付订单状态为已支付，更新成功往下走
        3. 创建支付成功的消息
        4. 将消息持久化数据库
        5. 发送消息到MQ（通知订单修改状态为已支付），等待发送结果,如果MQ接受到消息，删除发送成功的消息

####注意：第5步使用线程池


